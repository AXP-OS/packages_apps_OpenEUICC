package im.angry.openeuicc.util

import android.util.Log
import im.angry.openeuicc.core.EuiccChannel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import net.typeblog.lpac_jni.LocalProfileAssistant
import net.typeblog.lpac_jni.LocalProfileInfo

const val TAG = "LPAUtils"

val LocalProfileInfo.displayName: String
    get() = nickName.ifEmpty { name }


val LocalProfileInfo.isEnabled: Boolean
    get() = state == LocalProfileInfo.State.Enabled

val List<LocalProfileInfo>.operational: List<LocalProfileInfo>
    get() = filter {
        it.profileClass == LocalProfileInfo.Clazz.Operational
    }

val List<EuiccChannel>.hasMultipleChips: Boolean
    get() = distinctBy { it.slotId }.size > 1

/**
 * Disable the current active profile if any. If refresh is true, also cause a refresh command.
 * See EuiccManager.waitForReconnect()
 */
fun LocalProfileAssistant.disableActiveProfile(refresh: Boolean): Boolean =
    profiles.find { it.isEnabled }?.let {
        Log.i(TAG, "Disabling active profile ${it.iccid}")
        disableProfile(it.iccid, refresh)
    } ?: true

/**
 * Disable the active profile, return a lambda that reverts this action when called.
 * If refreshOnDisable is true, also cause a eUICC refresh command. Note that refreshing
 * will disconnect the eUICC and might need some time before being operational again.
 * See EuiccManager.waitForReconnect()
 */
fun LocalProfileAssistant.disableActiveProfileWithUndo(refreshOnDisable: Boolean): () -> Unit =
    profiles.find { it.isEnabled }?.let {
        disableProfile(it.iccid, refreshOnDisable)
        return { enableProfile(it.iccid) }
    } ?: { }

/**
 * Begin a "tracked" operation where notifications may be generated by the eSIM
 * Automatically handle any newly generated notification during the operation
 * if the function "op" returns true.
 */
suspend fun LocalProfileAssistant.beginTrackedOperation(op: suspend () -> Boolean) =
    withContext(Dispatchers.IO) {
        beginTrackedOperationBlocking { op() }
    }

inline fun LocalProfileAssistant.beginTrackedOperationBlocking(op: () -> Boolean) {
    val latestSeq = notifications.firstOrNull()?.seqNumber ?: 0
    Log.d(TAG, "Latest notification is $latestSeq before operation")
    if (op()) {
        Log.d(TAG, "Operation has requested notification handling")
        try {
            // Note that the exact instance of "channel" might have changed here if reconnected;
            // so we MUST use the automatic getter for "channel"
            notifications.filter { it.seqNumber > latestSeq }.forEach {
                Log.d(TAG, "Handling notification $it")
                handleNotification(it.seqNumber)
            }
        } catch (e: Exception) {
            // Ignore any error during notification handling
            e.printStackTrace()
        }
    }
    Log.d(TAG, "Operation complete")
}